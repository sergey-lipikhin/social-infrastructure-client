import{dB as j,O as H,hs as O,hk as Z,eA as P,u as v,a9 as A,ja as B,ip as F,aI as J,l as Q,gy as U,jb as K,jc as L,jd as T,je as W,aQ as $,aO as tt,jf as et,cg as nt,v as _,w as it,bE as st,jg as lt}from"./index-fdfa590d.js";function G(t,i,n,e){if(e==null||t.hasZ||(e=void 0),t.type==="point")return t.x+=i,t.y+=n,t.hasZ&&e!=null&&(t.z+=e),t;if(t.type==="multipoint"){const y=t.points;for(let a=0;a<y.length;a++)y[a]=k(y[a],i,n,e);return t}if(t.type==="extent")return t.xmin+=i,t.xmax+=i,t.ymin+=n,t.ymax+=n,e!=null&&(t.zmin??(t.zmin=0),t.zmin+=e,t.zmax??(t.zmax=0),t.zmax+=e),t;const o=j(t),s=t.type==="polyline"?t.paths:t.rings;for(let y=0;y<o.length;y++){const a=o[y];for(let l=0;l<a.length;l++)a[l]=k(a[l],i,n,e)}return"paths"in t?t.paths=s:t.rings=s,t}function rt(t,i,n,e,o){const s=t.clone(),y=e.resolution;if(s.type==="point"){if(o)G(s,i*y,-n*y);else{const a=e.state.transform,l=e.state.inverseTransform,r=a[0]*s.x+a[2]*s.y+a[4],h=a[1]*s.x+a[3]*s.y+a[5];s.x=l[0]*(r+i)+l[2]*(h+n)+l[4],s.y=l[1]*(r+i)+l[3]*(h+n)+l[5]}return s}if(s.type==="multipoint"){if(o)G(s,i*y,-n*y);else{const a=s.points,l=e.state.transform,r=e.state.inverseTransform;for(let h=0;h<a.length;h++){const p=a[h],m=l[0]*p[0]+l[2]*p[1]+l[4],d=l[1]*p[0]+l[3]*p[1]+l[5],u=r[0]*(m+i)+r[2]*(d+n)+r[4],g=r[1]*(m+i)+r[3]*(d+n)+r[5];a[h]=w(p,u,g,void 0)}}return s}if(s.type==="extent"){if(o)G(s,i*y,-n*y);else{const a=e.state.transform,l=e.state.inverseTransform,r=a[0]*s.xmin+a[2]*s.ymin+a[4],h=a[1]*s.xmin+a[3]*s.ymin+a[5],p=a[0]*s.xmax+a[2]*s.ymax+a[4],m=a[1]*s.xmax+a[3]*s.ymax+a[5];s.xmin=l[0]*(r+i)+l[2]*(h+n)+l[4],s.ymin=l[1]*(r+i)+l[3]*(h+n)+l[5],s.xmax=l[0]*(p+i)+l[2]*(m+n)+l[4],s.ymax=l[1]*(p+i)+l[3]*(m+n)+l[5]}return s}if(o)G(s,i*y,-n*y);else{const a=j(s),l=s.type==="polyline"?s.paths:s.rings,r=e.state.transform,h=e.state.inverseTransform;for(let p=0;p<a.length;p++){const m=a[p];for(let d=0;d<m.length;d++){const u=m[d],g=r[0]*u[0]+r[2]*u[1]+r[4],f=r[1]*u[0]+r[3]*u[1]+r[5],S=h[0]*(g+i)+h[2]*(f+n)+h[4],x=h[1]*(g+i)+h[3]*(f+n)+h[5];m[d]=w(u,S,x,void 0)}}"paths"in s?s.paths=l:s.rings=l}return s}function ht(t,i,n,e){if(t.type==="point"){const{x:u,y:g}=t,f=e?e[0]:u,S=e?e[1]:g,x=t.clone(),C=(u-f)*i+f,c=(g-S)*n+S;return x.x=C,x.y=c,x}if(t.type==="multipoint"){const u=j(t),g=H(),[f,S,x,C]=O(g,[u]),c=e?e[0]:(f+x)/2,M=e?e[1]:(C+S)/2,z=t.clone(),I=z.points;for(let D=0;D<I.length;D++){const E=I[D],[X,Y]=E,N=(X-c)*i+c,V=(Y-M)*n+M;I[D]=w(E,N,V,void 0)}return z}if(t.type==="extent"){const{xmin:u,xmax:g,ymin:f,ymax:S}=t,x=e?e[0]:(u+g)/2,C=e?e[1]:(S+f)/2,c=t.clone();if(c.xmin=(u-x)*i+x,c.ymax=(S-C)*n+C,c.xmax=(g-x)*i+x,c.ymin=(f-C)*n+C,c.xmin>c.xmax){const M=c.xmin,z=c.xmax;c.xmin=z,c.xmax=M}if(c.ymin>c.ymax){const M=c.ymin,z=c.ymax;c.ymin=z,c.ymax=M}return c}const o=j(t),s=H(),[y,a,l,r]=O(s,o),h=e?e[0]:(y+l)/2,p=e?e[1]:(r+a)/2,m=t.clone(),d=m.type==="polyline"?m.paths:m.rings;for(let u=0;u<o.length;u++){const g=o[u];for(let f=0;f<g.length;f++){const S=g[f],[x,C]=S,c=(x-h)*i+h,M=(C-p)*n+p;d[u][f]=w(S,c,M,void 0)}}return"paths"in m?m.paths=d:m.rings=d,m}function ct(t,i,n,e,o,s){const y=Math.sqrt((n-t)*(n-t)+(e-i)*(e-i));return Math.sqrt((o-t)*(o-t)+(s-i)*(s-i))/y}function yt(t,i,n,e=!1){const o=Math.atan2(i.y-n.y,i.x-n.x)-Math.atan2(t.y-n.y,t.x-n.x),s=Math.atan2(Math.sin(o),Math.cos(o));return e?s:Z(s)}function k(t,i,n,e){return w(t,t[0]+i,t[1]+n,t[2]!=null&&e!=null?t[2]+e:void 0)}function w(t,i,n,e){const o=[i,n];return t.length>2&&o.push(e??t[2]),t.length>3&&o.push(t[3]),o}function at(t){let i=0,n=0,e=0;return t?(t.type==="cim"&&t.data.symbol&&"symbolLayers"in t.data.symbol&&t.data.symbol.symbolLayers&&t.data.symbol.symbolLayers.map(o=>{o.type==="CIMVectorMarker"&&o.anchorPoint&&(Math.abs(o.anchorPoint.x)>i&&(i=o.anchorPoint.x),Math.abs(o.anchorPoint.y)>n&&(n=o.anchorPoint.y),o.size!=null&&o.size>e&&(e=o.size))}),i=P(i),n=P(n),e=P(e),{offsetX:i,offsetY:n,size:e}):{offsetX:i,offsetY:n,size:e}}let b=class extends A{set graphic(t){this._circleCollisionCache=null,this._originalSymbol=t.symbol,this._set("graphic",t),this.attachSymbolChanged()}get elevationInfo(){const{layer:t}=this.graphic,i=t&&"elevationInfo"in t?t.elevationInfo:null,n=B(this.graphic),e=i?i.offset:0;return new F({mode:n,offset:e})}set focusedSymbol(t){t!==this._get("focusedSymbol")&&(this._set("focusedSymbol",t),this._updateGraphicSymbol(),this._circleCollisionCache=null)}grabbableForEvent(){return!0}set grabbing(t){t!==this._get("grabbing")&&(this._set("grabbing",t),this._updateGraphicSymbol())}set hovering(t){t!==this._get("hovering")&&(this._set("hovering",t),this._updateGraphicSymbol())}set selected(t){t!==this._get("selected")&&(this._set("selected",t),this._updateGraphicSymbol(),this.events.emit("select-changed",{action:t?"select":"deselect"}))}get _focused(){return this._get("hovering")||this._get("grabbing")}constructor(t){super(t),this.layer=null,this.interactive=!0,this.selectable=!1,this.grabbable=!0,this.dragging=!1,this.cursor=null,this.events=new J.EventEmitter,this._circleCollisionCache=null,this._graphicSymbolChangedHandle=null,this._originalSymbol=null}destroy(){this.detachSymbolChanged(),this._resetGraphicSymbol(),this._set("view",null)}intersectionDistance(t){const i=this.graphic;if(i.visible===!1)return null;const n=i.geometry;if(n==null)return null;const e=this._get("focusedSymbol"),o=e??i.symbol;return this.view.type==="2d"?this._intersectDistance2D(this.view,t,n,o):this._intersectDistance3D(this.view,t,i)}attach(){this.attachSymbolChanged(),this.layer!=null&&this.layer.add(this.graphic)}detach(){this.detachSymbolChanged(),this._resetGraphicSymbol(),this.layer!=null&&this.layer.remove(this.graphic)}attachSymbolChanged(){this.detachSymbolChanged(),this._graphicSymbolChangedHandle=Q(()=>{var t;return(t=this.graphic)==null?void 0:t.symbol},t=>{t!=null&&t!==this.focusedSymbol&&t!==this._originalSymbol&&(this._originalSymbol=t,this._focused&&this.focusedSymbol!=null&&(this.graphic.symbol=this.focusedSymbol))},U)}detachSymbolChanged(){this._graphicSymbolChangedHandle!=null&&(this._graphicSymbolChangedHandle.remove(),this._graphicSymbolChangedHandle=null)}onElevationChange(){}onViewChange(){}_updateGraphicSymbol(){this.graphic.symbol=this._focused&&this.focusedSymbol!=null?this.focusedSymbol:this._originalSymbol}_resetGraphicSymbol(){this.graphic.symbol=this._originalSymbol}_intersectDistance2D(t,i,n,e){var y,a;if((e=e||K(n))==null)return null;const o=1;let s=this._circleCollisionCache;if(n.type==="point"&&e.type==="cim"&&((y=e.data.symbol)==null?void 0:y.type)==="CIMPointSymbol"&&e.data.symbol.symbolLayers){const{offsetX:l,offsetY:r,size:h}=at(e),p=L(i,R),m=h/2,d=t.toScreen(n),u=d.x+l,g=d.y+r;return T(p,[u,g])<m*m?o:null}if(n.type!=="point"||e.type!=="simple-marker")return W(i,n,t)?o:null;if(s==null||!s.originalPoint.equals(n)){const l=n,r=t.spatialReference;if($(l.spatialReference,r)){const h=tt(l,r);s={originalPoint:l.clone(),mapPoint:h,radiusPx:P(e.size)},this._circleCollisionCache=s}}if(s!=null){const l=L(i,R),r=(a=t.toScreen)==null?void 0:a.call(t,s.mapPoint);if(!r)return null;const h=s.radiusPx,p=r.x+P(e.xoffset),m=r.y-P(e.yoffset);return T(l,[p,m])<h*h?o:null}return null}_intersectDistance3D(t,i,n){const e=t.toMap(i,{include:[n]});return e&&et(e,q,t.renderSpatialReference)?nt(q,t.state.camera.eye):null}};v([_({constructOnly:!0,nonNullable:!0})],b.prototype,"graphic",null),v([_()],b.prototype,"elevationInfo",null),v([_({constructOnly:!0,nonNullable:!0})],b.prototype,"view",void 0),v([_({value:null})],b.prototype,"focusedSymbol",null),v([_({constructOnly:!0})],b.prototype,"layer",void 0),v([_()],b.prototype,"interactive",void 0),v([_()],b.prototype,"selectable",void 0),v([_()],b.prototype,"grabbable",void 0),v([_({value:!1})],b.prototype,"grabbing",null),v([_()],b.prototype,"dragging",void 0),v([_()],b.prototype,"hovering",null),v([_({value:!1})],b.prototype,"selected",null),v([_()],b.prototype,"cursor",void 0),b=v([it("esri.views.interactive.GraphicManipulator")],b);const q=st(),R=lt();export{b as S,ct as a,at as b,rt as i,yt as m,G as r,ht as s};
